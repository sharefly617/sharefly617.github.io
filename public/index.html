<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>噗噗噗的Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="噗噗噗的Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="噗噗噗的Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="噗噗噗的Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="index.html" id="logo">噗噗噗的Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="index.html">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-小白也能看懂的卷积" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2022/06/06/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8D%B7%E7%A7%AF/" class="article-date">
  <time datetime="2022-06-05T16:00:00.000Z" itemprop="datePublished">2022-06-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E4%BF%A1%E5%8F%B7/">信号</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/06/06/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8D%B7%E7%A7%AF/">小白也能看懂的卷积！</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><meta name="referrer" content="no-referrer"><br>对于很多朋友们来说，刚接触到卷积这个概念的时候一定都有一点头疼，我也不例外。随着学习的加深，回顾卷积概念的时候我也有了一些新的理解。思索再三还是提笔写下这个小白都能看懂的卷积。提前说明，该教程的讲解都基于离散时间情况。</p>
<h1 id="伤害到底是多少？"><a href="#伤害到底是多少？" class="headerlink" title="伤害到底是多少？"></a><center>伤害到底是多少？</center></h1><p>&emsp;你叫张三，是游戏里的主角，武器是一把菜刀。随着打怪升级，菜刀的攻击属性也越来越高，直到菜刀升到了第五级，菜刀便拥有了新的技能：毒性伤害，可以对对手造成持续性的伤害。不过伤害会随着时间的增加逐渐减少，单位力度造成的伤害随时间的变化如， 暂且叫它$h[t]$</p>
<p><img src="https://img-blog.csdnimg.cn/direct/71f5097ecf8a4d53b11e9d52bc952b35.png" alt="毒性伤害"></p>
<p>&emsp;每一次出招的伤害和出招的力度有关，力度越大，造成的总伤害也越大。<script type="math/tex">\text{总伤害}=\text{力度}\times \text{单位力度伤害}</script><br>随着技能升级，你，张三，在$30$级的时候学会了一个新连招————-乱披风刀法。这套连招拥有4次攻击，可以表示成,暂且叫它$x[t]$。<br><img src="https://img-blog.csdnimg.cn/direct/3d2752cd1b1140c5bf47d586abd202b7.png" alt="乱披风刀法攻击组成"></p>
<p>可以看到，在使出乱披风刀法连招的第$0$秒，第$1$秒，第$3$秒和第$6$秒都有一次攻击。那么问题来了，在使用毒性菜刀配合乱披风刀法攻击的时候，这一套连击总共能给boss带来多大的伤害呢。</p>
<p>第一个想法：可以把连招中的4次攻击拆开单看，计算每一次单独攻击造成的伤害，然后求和就行。分别来看看4次攻击的伤害是多少，我们说过<script type="math/tex">\text{总伤害}=\text{力度}\times \text{单位力度伤害}</script>不过，在这里要注意使时间的变化。比如在第$6$秒时，$h[t]$变成了$h[t-6]$。四次攻击的伤害可以表示成：<br><img src="https://img-blog.csdnimg.cn/direct/7d3c5e1a78fa4d84851bea0465d56530.png" alt="h(t-0)"><br>\<br>将四张图叠加到一起，就可以得到乱劈风刀法伤害随时间变化的关系图，如所示。<br><img src="https://img-blog.csdnimg.cn/direct/01d3166e2c5a4eafb89b0d7c0a8a9a14.png" alt="乱劈风刀法伤害-时间关系"></p>
<p>我们将乱劈风刀法伤害-时间关系称为$y[t]$，要得到一套乱劈风刀法伤害造成的总伤害，我们只需要在时间尺度上对$y[t]$进行求和得到$\sum_{t=-\infty}^{\infty}y[t]$即可。</p>
<p>不知不觉间，在求乱劈风刀法伤害-时间关系$y[t]$的过程中，我们已经完成了一次卷积求和操作。或许你还有所疑问，这怎么就是卷积和了呢，我们来看看$y[t]$的组成:</p>
<script type="math/tex; mode=display">
y[t] = x[0]h[t-0]+x[1]h[t-1]+x[3]h[t-3]+x[6]h[t-6]</script><p>如果我们把上式中省略的$x[t]=0$的部分补上，可以得到</p>
<script type="math/tex; mode=display">y[t] = \sum_{k=-\infty}^{\infty}x[k]h[t-k]</script><p>这就是我们认知中的卷积和公式，也可以写成简洁形式$y[t]=x[t]*h[t]$。</p>
<p>在上述叠加的过程中可以看出来，$y[t]$当中的每一项，比如第八秒boss收到的伤害$y[8]$，是由所有$x[k]$在第8秒时的伤害贡献相加的结果的结果。具体来说，在乱劈风刀法第$0$秒的攻击在第$8$秒造成的伤害应该是$x[0]h[8]$，可以表示成图a:<br><img src="https://img-blog.csdnimg.cn/direct/2af20828097645e9b1b9e7c2267375c3.png" alt="卷积过程1"></p>
<p>而乱劈风刀法第$1$秒的攻击在第$8$秒造成的伤害应该是是什么呢？花三秒时间思考一下。没错，不是$x[0]h[8]$了，应该是$x[1]h[7]$。因为在$x[1]$攻击发出之后，再过$7$秒就是第$8$秒了，可以表示成图b。</p>
<p>所以当考虑所有$x[k]$在第8秒时的伤害贡献时，可以得到c。</p>
<p>再次归纳一下，当我们考虑第$n$秒造成的攻击$y[n]$时，我们考虑每个单次攻击$x[k]$乘以其在$n-k$造成的单位力度伤害，即$h[n-k]$，因为相对于第$k$秒的攻击$x[k]$,在过$n-k$秒就是第$n$秒了。这就是从另一个角度理解卷积和公式$y[t] = \sum_{k=-\infty}^{\infty}x[k]h[t-k]$。不过上图怎么看都有点不舒服，连接线全部拧着(上图省略了$x[k]=0$的连接线)。不如先将$h[k]$(暂时将自变量换个名字)翻转一下变成$h[-k]$，这时得到了图形d。</p>
<p>图仍然有点别扭，我们将$h[-k]$向右做一些平移得到$h[n-k]$(不理解为什么是向右平移的同学从$h[-(n+k)]$这个角度思考)，可以得到图:</p>
<p><img src="https://img-blog.csdnimg.cn/direct/13be8d87028746898d0eb965fe46aebd.png" alt="$h[-k]$平移之后的求和"></p>
<p>这也就是我们在上课和国内教材中经常被教的：卷积就是翻转，平移，求和的过程。</p>
<p>想要真正了解卷积的难点，我们应该把目光关注到$h[k]$上，卷积现象的产生是因为$h[k]$在输入消失之后仍然会产生输出，有一种\”语音绕梁，三日不绝\”的意味。所以我们求某一$t$时刻的输出的时候，其实需要算上$t$时刻之前的输入有没有产生”造福后世”的影响，也需要检查一下$t$时刻之后的输入有没有穿越时空来形成”蝴蝶效应”(这种情况极其罕见)。所以，列举出一些其他关于卷积的例子，我们只需要列举出能够持续对之后时刻产生影响的例子即可。比如想要计算某一$t$时刻的血糖指数，需要考虑$t$之前所有时刻消化的食物对$t$时刻血糖的影响。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/06/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8D%B7%E7%A7%AF/" data-id="clr7f8dsy000ankvt71cdbyae" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MCMC系列：Metropololis-Hasting采样算法，10分钟从零到大神" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2022/06/02/MCMC%E7%B3%BB%E5%88%97%EF%BC%9AMetropololis-Hasting%E9%87%87%E6%A0%B7%E7%AE%97%E6%B3%95%EF%BC%8C10%E5%88%86%E9%92%9F%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%A4%A7%E7%A5%9E/" class="article-date">
  <time datetime="2022-06-01T16:00:00.000Z" itemprop="datePublished">2022-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E4%BF%A1%E5%8F%B7/">信号</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/06/02/MCMC%E7%B3%BB%E5%88%97%EF%BC%9AMetropololis-Hasting%E9%87%87%E6%A0%B7%E7%AE%97%E6%B3%95%EF%BC%8C10%E5%88%86%E9%92%9F%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%A4%A7%E7%A5%9E/">MCMC系列：Metropololis-Hasting采样算法，10分钟从零到大神</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MCMC"><a href="#MCMC" class="headerlink" title="MCMC"></a>MCMC</h1><p>面对已知的复杂分布时，仅知其表达式，对其进行采样变得格外棘手（甚至无法采样）。在仿真中，各工具包会提供一些标准分布，MCMC采样方法允许我们通过构造一个马尔科夫链，并借助标准分布，使得以某种接受概率采样的新马尔科夫链的平稳分布为我们的目标复杂分布。</p>
<h2 id="Metropolis-Hasting"><a href="#Metropolis-Hasting" class="headerlink" title="Metropolis-Hasting"></a>Metropolis-Hasting</h2><p>MCMC中很重要且很实用的一个采样算法就是MH算法。</p>
<h3 id="MH算法流程-怎么做"><a href="#MH算法流程-怎么做" class="headerlink" title="MH算法流程(怎么做)"></a>MH算法流程(怎么做)</h3><p><img src="https://img-blog.csdnimg.cn/da80fe5bb4c94854b8a02a35b5cb1702.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYXJlNzI3MTg2NjMw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="这么做为什么行-MH推导"><a href="#这么做为什么行-MH推导" class="headerlink" title="这么做为什么行(MH推导)"></a>这么做为什么行(MH推导)</h3><h4 id="从马尔可夫链谈起-重点版"><a href="#从马尔可夫链谈起-重点版" class="headerlink" title="从马尔可夫链谈起(重点版)"></a>从马尔可夫链谈起(重点版)</h4><p>如何构建一个平稳分布为目标分布马尔科夫链？可在此简要介绍会用到的马尔可夫链的重要性质(假设读者了解马尔科夫链的基本概念)：</p>
<p><em>稳态分布</em>  <strong>什么是稳态分布呢(stationary/invariant distribution)?</strong> 定义$(X_n)_{n\geq 0}$为马氏链$(\lambda,P)$。当马尔可夫链$(X_n)_{n\geq 0}$的状态分布为$\lambda$时，此时若$\pi$满足</p>
<script type="math/tex; mode=display">\pi P=\pi</script><p>那么$pi$则是该马尔科夫链的平稳分布。通俗理解即为某一时刻马尔科夫链的状态服从某一个分布之后，再进行转移，其状态仍然服从此分布(服从分布不是状态保持不变)。至此，已经阐明为何可以使用马尔可夫链进行采样。</p>
<p>但是如何找到平稳分布呢？MH中利用了马尔科夫链的细致平衡方程(detailed<br>balance equations),满足细致平衡方程的的分布就是马氏链的平稳分布。</p>
<p><strong>定理 1.1</strong>.<br><em>如果存在一个分布$\pi$满足<script type="math/tex">\pi_i P_{ij} = \pi_j P_{ji},</script> 那么$\pi$就是该马氏链的平稳分布。</em></p>
<p><strong>Proof.</strong> <em><script type="math/tex">\sum_{i} \pi_i P_{ij}=\sum_{i}\pi_j P_{ji}=\pi_j</script> ◻</em></p>
<h4 id="回到MH算法（Metropolis-Hastings-algorithm）"><a href="#回到MH算法（Metropolis-Hastings-algorithm）" class="headerlink" title="回到MH算法（Metropolis Hastings algorithm）"></a>回到MH算法（Metropolis Hastings algorithm）</h4><p>介绍完马氏链的平稳分布后，可以发现，MH算法就是在构造马氏链满足细致平稳条件的转移概率，使其平稳分布为我们的目标分布。在中的第5行构造了转移的接受概率，马氏链的转移分布由提议分布$q$决定，此时$P_{ij}=q(x_j|x_i)$。考虑$\alpha_{ij}&lt;1$的情况，有</p>
<script type="math/tex; mode=display">p_i Q_{ij} = p_i P_{ij} \alpha_{ij} =p_i q(x_j|x_i) \frac{p_jq(x_i|x_j)}{p_i q(x_j|x_i)}=p_jq(x_i|x_j)\alpha_{ji}=p_j Q_{ji}</script><p>可以发现这样构造出来的新马氏链(实际上叫做MH链或者MH马氏链)的平稳分布就是需要被采样的目标分布了。那么对这个MH链采样一段时间后(burn<br>in)，MH链会收敛到平稳分布。</p>
<h4 id="问题再现，再次回到马氏链"><a href="#问题再现，再次回到马氏链" class="headerlink" title="问题再现，再次回到马氏链"></a>问题再现，再次回到马氏链</h4><p>读者不免会产生一定的疑问:对于一个马氏链来说平稳分布一定存在且唯一吗？会不会存在一个马氏链有多个平稳分布的情况呢？老规矩，先说结论：对于有限空间的马尔科夫链，平稳分布一定存在，对于不可约的(状态互通)马尔科夫链，平稳分布就是唯一的。</p>
<p><strong>Proof.</strong><br><strong>声明！本证明已掏空笔者！！</strong><br>首先解释何为<strong>不可约(状态互通)</strong>，即状态之间能够互通。从状态$i$经过$n$步之后可以到达状态$j$，即$Pr(x_n=j|x_0=i,n&lt;-\infty)&gt;0$。状态矩阵$P^n$中的每一个元素都大于$0$，所以，不可约马氏链的状态矩阵是一个正则矩阵(regular matrix)。[<em>$A$ is called regular if for some $k&gt;1$,$A^k&gt;0$.</em>]根据Perron-Frobenius定理，若一个矩阵$A$是正则矩阵，则</p>
<ol>
<li><p>$A$存在一个正实特征值$\lambda_{PF}$，其对应的左、右特征向量也均为正特征向量。</p>
</li>
<li><p>$A$的所有其他特征值都存在$\lambda_i &lt; \lambda_{PF}$。</p>
</li>
<li><p>$\lambda_{PF}=1$，且其左、右特征向量的模为$1$。</p>
</li>
</ol>
<p>那么马氏链的转移矩阵$P$只有一个特征向量$\pi$能够满足<br>$\pi P=1\cdot\pi$ ◻<br>证明了不可约的马氏链只一个单独的平稳分布之后，就容易理解为什么满足细致平衡方程的分布就是批评翁分布。至此，MH为什么可行就得到了证明。</p>
<h4 id="真的结束了吗？补充证明"><a href="#真的结束了吗？补充证明" class="headerlink" title="真的结束了吗？补充证明"></a>真的结束了吗？补充证明</h4><p>真的结束了吗。不妨思考，需要被采样的空间是一个有限空间吗？对目标分布进行采样，明明可以得到无数的采样值。这样之前证明的前提便全部被推翻了呀！<br>在此，引入新的概念，马尔科夫链的另一种分类，countable-state<br>chain，旨在描述类似连续分布采样过程的离散时间无限空间的马尔科夫链。那无限空间的马氏链仍然只有唯一的平稳分布吗。结论：对于不可约的马尔科夫链，如果</p>
<p><script type="math/tex">\pi P=\pi</script>有解，那么这个解是唯一的。相反，如果马氏链是正常反的，那么就一定有解。在此不对上述结论进行证明，有意者可以参考\<Stochastic processes:theory for applications>的第298页的定理6.3.8.</Stochastic></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/02/MCMC%E7%B3%BB%E5%88%97%EF%BC%9AMetropololis-Hasting%E9%87%87%E6%A0%B7%E7%AE%97%E6%B3%95%EF%BC%8C10%E5%88%86%E9%92%9F%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%A4%A7%E7%A5%9E/" data-id="clr7f8dsp0000nkvtdomt34df" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" rel="tag">统计学</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Tensor 储存字典的key，如何将字典的value填入Tensor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2022/06/02/Tensor%20%E5%82%A8%E5%AD%98%E5%AD%97%E5%85%B8%E7%9A%84key%EF%BC%8C%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E5%85%B8%E7%9A%84value%E5%A1%AB%E5%85%A5Tensor/" class="article-date">
  <time datetime="2022-06-01T16:00:00.000Z" itemprop="datePublished">2022-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/06/02/Tensor%20%E5%82%A8%E5%AD%98%E5%AD%97%E5%85%B8%E7%9A%84key%EF%BC%8C%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E5%85%B8%E7%9A%84value%E5%A1%AB%E5%85%A5Tensor/">Tensor 储存字典的key，如何将字典的value填入Tensor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><meta name="referrer" content="no-referrer"><br>最近遇到一个问题，假设一个Tensor的元素都是标签（字典的key），这里我们还有一个对应的字典，如果想把key对应的value填回tensor，怎么操作呢？<br>当然如果是在numpy中，我们可以循环遍历这个字典，然后修改元素的值，但是在tensor中是没有这么容易可以修改特定的元素的数值的。可能有些同学会自然想到把tensor转换成numpy.array再进行操作即可。这种想法不错，但是在使用keras 或者tensorflow时，在这里我默认大家在进行机器学习。显然循环操作和转换会大大减小效率。<br>tf和keras中的gather函数可以解决这个问题，这里我以keras为例。<br><strong><em>gather函数的官方解答</em></strong><br><code>keras.backend.gather(reference, indices)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在张量 reference 中检索索引 indices 的元素。</span><br><span class="line">参数</span><br><span class="line">reference: 一个张量。</span><br><span class="line">indices: 索引的整数张量。</span><br><span class="line">返回 ：与 reference 类型相同的张量。</span><br><span class="line">Numpy 实现</span><br><span class="line">def gather(reference, indices):</span><br><span class="line">    return reference[indices]</span><br></pre></td></tr></table></figure>
<p>说白了就是在我们需要实现的功能，只不过这里的字典的key是一些索引，所以仅限数字，而且类型还的是int64</p>
<p><strong>上实战代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import keras.backend as K</span><br><span class="line"></span><br><span class="line">a = [[[1],[2],[2]],[[1],[1],[2]]]</span><br><span class="line">variable = K.constant(a,dtype = &#x27;int32&#x27;)</span><br><span class="line">d1,d2,d3 = [1,2,3,1],[2,3,4,2],[3,4,5,5]</span><br><span class="line">c = &#123;0:d1,1:d2,2:d3&#125;</span><br><span class="line">#获取dict的所有value</span><br><span class="line">value = K.constant(list(c.values()))</span><br></pre></td></tr></table></figure>
<p>==我们来看看value的值==</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">K.eval(value)</span><br><span class="line">Out[3]: </span><br><span class="line">array([[1., 2., 3., 1.],</span><br><span class="line">       [2., 3., 4., 2.],</span><br><span class="line">       [3., 4., 5., 5.]], dtype=float32)</span><br><span class="line">属性：Tensor(&quot;Const_1:0&quot;, shape=(3, 4), dtype=float32)</span><br></pre></td></tr></table></figure>
<p>接着操作   <code>K.gather(value,variable)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Out[6]: </span><br><span class="line">array([[[[2., 3., 4., 2.]],</span><br><span class="line">        [[3., 4., 5., 5.]],</span><br><span class="line">        [[3., 4., 5., 5.]]],</span><br><span class="line">       [[[2., 3., 4., 2.]],</span><br><span class="line">        [[2., 3., 4., 2.]],</span><br><span class="line">        [[3., 4., 5., 5.]]]], dtype=float32)</span><br><span class="line">Tensor(&quot;embedding_lookup_1/Identity:0&quot;, shape=(2, 3, 1, 4), dtype=float32)</span><br></pre></td></tr></table></figure>
<p>塔哒成功了，帮助到了你就给我评论下吧</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/02/Tensor%20%E5%82%A8%E5%AD%98%E5%AD%97%E5%85%B8%E7%9A%84key%EF%BC%8C%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E5%85%B8%E7%9A%84value%E5%A1%AB%E5%85%A5Tensor/" data-id="clr7f8dss0001nkvt3kyd96vd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/tensorflow/" rel="tag">tensorflow</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-复随机变量" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2022/06/02/%E5%A4%8D%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/" class="article-date">
  <time datetime="2022-06-01T16:00:00.000Z" itemprop="datePublished">2022-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E4%BF%A1%E5%8F%B7/">信号</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/06/02/%E5%A4%8D%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/">复随机变量</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Proper-Complex-Random-Vectors"><a href="#Proper-Complex-Random-Vectors" class="headerlink" title="Proper Complex Random Vectors"></a>Proper Complex Random Vectors</h2><p><strong>定义：</strong><br>&emsp;当一个复随机矢量$\mathbf{Z}$满足以下条件时，我们称它为<strong>Proper</strong>:</p>
<ol>
<li>均值为0</li>
<li>方差为有限值(不是$\pm\infty$)</li>
<li>$\mathrm{E}[\mathbf{ZZ}^T]=0$</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/02/%E5%A4%8D%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/" data-id="clr7f8dsv0004nkvt89y9f7qn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" rel="tag">统计学</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Trace—σ代数的证明" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2022/06/02/Trace%E2%80%94%CF%83%E4%BB%A3%E6%95%B0%E7%9A%84%E8%AF%81%E6%98%8E/" class="article-date">
  <time datetime="2022-06-01T16:00:00.000Z" itemprop="datePublished">2022-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E4%BF%A1%E5%8F%B7/">信号</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/06/02/Trace%E2%80%94%CF%83%E4%BB%A3%E6%95%B0%E7%9A%84%E8%AF%81%E6%98%8E/">Trace—σ代数的证明</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><meta name="referrer" content="no-referrer"><br>本文旨在证明 Trace $\sigma$ algebra 是一个algebra。Trace $\sigma$ algebra 的定义是：</p>
<blockquote>
<p>假设$E\subseteq  X$，且$\mathscr{A}$是X上的$\sigma$代数，那么<br>$\mathscr{A}_{E}$ $\vcentcolon=$ $\{E \cap{A} , A\in\mathscr{A}\}$是一个$E$上的$\sigma$ algebra。</p>
<p>证明，根据定义的三条，第一条$E\in\mathscr{A}_{E}$明显满足。<br>第二条，需要证明$E$的子集$A\in\mathscr{A}_{E}$那么$E\setminus A\in\mathscr{A}_{E}$<br>假设一些S=E$\cap$A$,$A$\in$$\mathscr{A}_E$，因此，$X\setminus S\in\mathscr{A}$,那么根据定义$E\cap(X\setminus S)\in\mathscr{A}_E$而$E\cap(X\setminus S)=(E\cap X)\setminus S=E\setminus S$,所以$E\setminus S \in \mathscr{A}_E$。</p>
</blockquote>
<p>第三条需要证明的条件是：$A_i\in \mathscr{A}_E,那么\cup _{i\in\mathbb{N}}A_i\in\mathscr{A}_E$。<br>证明过程如下：<br>根据定义假设$S_i=E\cap A_i$其中$A_i \in \mathscr{A}$,那么$\cup S_i=E\cap \{\cup A_i\}$，由于$\mathscr{A}$是$\sigma$-algebra，所以$\{\cup A_i\} \in \mathscr{A}$ ,根据定义$\cup S_i \in \mathscr{A}_E$.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/02/Trace%E2%80%94%CF%83%E4%BB%A3%E6%95%B0%E7%9A%84%E8%AF%81%E6%98%8E/" data-id="clr7f8dsw0005nkvt0k0xed69" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" rel="tag">统计学</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-官方文档没讲清楚？？？Pytorch中神奇函数方法map()_" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2022/06/02/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%B2%A1%E8%AE%B2%E6%B8%85%E6%A5%9A%EF%BC%9F%EF%BC%9F%EF%BC%9FPytorch%E4%B8%AD%E7%A5%9E%E5%A5%87%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95map()_/" class="article-date">
  <time datetime="2022-06-01T16:00:00.000Z" itemprop="datePublished">2022-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/06/02/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%B2%A1%E8%AE%B2%E6%B8%85%E6%A5%9A%EF%BC%9F%EF%BC%9F%EF%BC%9FPytorch%E4%B8%AD%E7%A5%9E%E5%A5%87%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95map()_/">官方文档没讲清楚？？？Pytorch中神奇函数方法map()</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><meta name="referrer" content="no-referrer"><br>在python中有一个高级函数叫做map()<br>引用廖雪峰的讲解</p>
<blockquote>
<p>如果你读过Google的那篇大名鼎鼎的论文“MapReduce: Simplified Data Processing on Large Clusters”，你就能大概明白map/reduce的概念。<br>我们先看map。map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<br>举例说明，比如我们有一个函数$f(x)=x^2$，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200721170555544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYXJlNzI3MTg2NjMw,size_16,color_FFFFFF,t_70#pic_center" alt="$f(x)=x2$"><br>代码实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">	 return x * x</span><br><span class="line"> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line"> list(r)</span><br><span class="line"> [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure><br>说的很清楚了，返回的是一个$Iterator$,那么在pytorch中相对torch.Tensor中的每一个element进行函数运算有没有torch的函数呢，我查了下，还真有。来看看官方文档的教程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map_(tensor, callable)</span><br><span class="line">Applies callable for each element in self tensor and the given tensor and stores the results in self tensor. </span><br><span class="line">self tensor and the given tensor must be broadcastable.</span><br><span class="line"></span><br><span class="line">The callable should have the signature:</span><br><span class="line">def callable(a, b) -&gt; number</span><br></pre></td></tr></table></figure>
<p>等等？这是神马？完全没说清楚啊，$callable()$我可以理解，就是可调用的对象。但是这个参数$(a,b)$是哪里来的？？？？$python$中的$map$不是$f$接受$Iteratorable$里面返回的每一个对象吗，返回一个就是一个参数，返回两个就是两个参数啊，这里为啥是$(a,b)$两个参数？？？？<br>假设有一个tensor,我想令每一个元素的操作编程$f = 4\times{x}+10$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">improt torch</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>): <span class="keyword">return</span> <span class="number">4</span>*x+<span class="number">10</span></span><br><span class="line">torch.randint(<span class="number">0</span>,<span class="number">3</span>,(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>这个时候对$x$用上$map_()$函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.map_(x,f)</span><br><span class="line"></span><br><span class="line">出现的是这个：TypeError: f() takes <span class="number">1</span> positional argument but <span class="number">2</span> were given</span><br></pre></td></tr></table></figure>
<p>咦，怎么还真是传入了两个参数啊，这两个参数是啥啊？？<br><strong>好了这里就不卖关子了</strong> ，这两个参数其实就是$Iteratorable$里面返回的每一个对象的两份同样的值，也就是说$a=b$,那我们需要把函数改一下,传入两个参数，但是只要一个就行了，或者使用多参数的形式$*karg$：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x,*y</span>): <span class="keyword">return</span> <span class="number">4</span>*x+<span class="number">10</span></span><br><span class="line">x = torch.randint(<span class="number">0</span>,<span class="number">3</span>,(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原来的x是\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line">x.map_(x,f)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原来的x是</span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line">tensor([[<span class="number">14</span>, <span class="number">10</span>, <span class="number">10</span>],</span><br><span class="line">        [<span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>]])</span><br></pre></td></tr></table></figure>
<p>这样就完成了我们的目标，代码也变得简洁了很多，是不是很开心呢？</p>
<p><strong>原创不易，点个赞再走吧！</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/02/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%B2%A1%E8%AE%B2%E6%B8%85%E6%A5%9A%EF%BC%9F%EF%BC%9F%EF%BC%9FPytorch%E4%B8%AD%E7%A5%9E%E5%A5%87%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95map()_/" data-id="clr7f8dsx0006nkvterj126dp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Pytorch/" rel="tag">Pytorch</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-高斯分布的数乘，相加，相乘还是高斯分布吗？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2022/06/02/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E6%95%B0%E4%B9%98%EF%BC%8C%E7%9B%B8%E5%8A%A0%EF%BC%8C%E7%9B%B8%E4%B9%98%E8%BF%98%E6%98%AF%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E5%90%97%EF%BC%9F/" class="article-date">
  <time datetime="2022-06-01T16:00:00.000Z" itemprop="datePublished">2022-06-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E4%BF%A1%E5%8F%B7/">信号</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/06/02/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E6%95%B0%E4%B9%98%EF%BC%8C%E7%9B%B8%E5%8A%A0%EF%BC%8C%E7%9B%B8%E4%B9%98%E8%BF%98%E6%98%AF%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E5%90%97%EF%BC%9F/">高斯分布的数乘，相加，相乘还是高斯分布吗</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="高斯分布的数乘，相加，相乘还是高斯分布吗？"><a href="#高斯分布的数乘，相加，相乘还是高斯分布吗？" class="headerlink" title="高斯分布的数乘，相加，相乘还是高斯分布吗？"></a>高斯分布的数乘，相加，相乘还是高斯分布吗？</h1><p>&emsp;首先当随机变量$Y=g(X)$时,两者的PDF具有这样的关系<script type="math/tex">f_{Y}(y)=f_{X}(x)\lvert\frac{dx}{dy}\rvert</script><br>具体来说<script type="math/tex">F_{Y}(y)=P(Y\leq y)=P\left(g(X)\leq y\right)=P\left(X\leq g^{-1}(y)\right)=F_{X}( g^{-1}(y)) = F_{X}(x)</script><br>知道上述关系之后，考虑随机变量$Y=aX$，其中$X\sim\mathcal{N}(\mu,\sigma^2)$，则</p>
<script type="math/tex; mode=display">\begin{aligned}f_{Y}(y)&=\frac{1}{a}f_{X}(x)\\
&=\frac{1}{a}f_{X}(\frac{y}{a})\\
&=\frac{1}{\sqrt{2\pi}a\sigma}\exp(-\frac{(\frac{y}{a}-\mu)^2}{2\sigma^2})\\
&=\frac{1}{\sqrt{2\pi}(a\sigma)}\exp(-\frac{(y-a\mu)^2}{2(a\sigma)^2})
\end{aligned}</script><p>所以$Y\sim\mathcal{N}(a\mu,(a\sigma^2))$，可得知高斯分布的数乘还是高斯分布。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/02/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E6%95%B0%E4%B9%98%EF%BC%8C%E7%9B%B8%E5%8A%A0%EF%BC%8C%E7%9B%B8%E4%B9%98%E8%BF%98%E6%98%AF%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E5%90%97%EF%BC%9F/" data-id="clr7f8dt4000tnkvt9dkm968n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-正态分布推导瑞利分布，瑞利信道的模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2022/06/01/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E6%8E%A8%E5%AF%BC%E7%91%9E%E5%88%A9%E5%88%86%E5%B8%83%EF%BC%8C%E7%91%9E%E5%88%A9%E4%BF%A1%E9%81%93%E7%9A%84%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2022-06-01T13:39:59.000Z" itemprop="datePublished">2022-06-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E4%BF%A1%E5%8F%B7/">信号</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/06/01/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E6%8E%A8%E5%AF%BC%E7%91%9E%E5%88%A9%E5%88%86%E5%B8%83%EF%BC%8C%E7%91%9E%E5%88%A9%E4%BF%A1%E9%81%93%E7%9A%84%E6%A8%A1%E5%9E%8B/">正态分布推导瑞利分布，瑞利信道的模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><meta name="referrer" content="no-referrer"></p>
<h2 id="从高斯分布推导瑞利分布"><a href="#从高斯分布推导瑞利分布" class="headerlink" title="从高斯分布推导瑞利分布"></a>从高斯分布推导瑞利分布</h2><p>瑞利分布是无线通信中常见的信道模型，这里就来推导一下，所谓瑞利分布就是两个垂直分量服从独立且相同的标准高斯分布叠加之后的模。先来看看高斯分布的表达式</p>
<script type="math/tex; mode=display">f(x) = \frac{1}{\sqrt{2\pi}\sigma}\exp\left(-\frac{(x-\mu)^2}{2{\sigma}^2}\right)</script><p>其中$\sigma$是分布的方差，$\mu$是分布的均值。<br>假设$X_1,X_2\sim N(0,{\sigma}^2)$,$X^2 = {X_1}^2+{X_2}^2$,现在需要推导$X$的概率密度函数。$x_1$和$x_2$的联合概率密度 如下：</p>
<script type="math/tex; mode=display">\begin{aligned}
f(x_1,x_2) = \frac{1}{2\pi\sigma^2}\exp\left(-\frac{x_1^2+x_2^2}{2{\sigma}^2}\right).
\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}
F(X)=P(X\leq x)&= P(\sqrt{ {X_1}^2+{X_2}^2}\leq x)\\
&=\iint\limits_ { {x_1}^2+{x_2}^2{\leq}x}\frac{1}{2\pi\sigma^2}\exp\left(-\frac{x_1^2+x_2^2}{2{\sigma}^2}\right)dx_1dx_2\\
&=\frac{1}{2\pi\sigma^2}\int_{0}^{2\pi}d\theta\int_{0}^{x}r\exp\left(-\frac{r^2}{2{\sigma}^2}\right)dr\\
&=1-\exp\left(-\frac{x^2}{2{\sigma}^2}\right)
\end{aligned}</script><p>此时$f(x)=F’(x)=\frac{x}{ {\sigma}^2}\exp\left(-\frac{x^2}{2{\sigma}^2}\right)$,注意上述积分的定义域是$x\geq0$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/01/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E6%8E%A8%E5%AF%BC%E7%91%9E%E5%88%A9%E5%88%86%E5%B8%83%EF%BC%8C%E7%91%9E%E5%88%A9%E4%BF%A1%E9%81%93%E7%9A%84%E6%A8%A1%E5%9E%8B/" data-id="clr7f8dsz000cnkvt0g20cvx9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-论文导读：使用松弛半定规划的方法进行数据降维--通过最大最小距离" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2022/06/01/%E8%AE%BA%E6%96%87%E5%AF%BC%E8%AF%BB%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9D%BE%E5%BC%9B%E5%8D%8A%E5%AE%9A%E8%A7%84%E5%88%92%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4--%E9%80%9A%E8%BF%87%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/" class="article-date">
  <time datetime="2022-06-01T13:39:59.000Z" itemprop="datePublished">2022-06-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/%E4%BF%A1%E5%8F%B7/">信号</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2022/06/01/%E8%AE%BA%E6%96%87%E5%AF%BC%E8%AF%BB%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9D%BE%E5%BC%9B%E5%8D%8A%E5%AE%9A%E8%A7%84%E5%88%92%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4--%E9%80%9A%E8%BF%87%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/">论文导读：使用半定规划的方法进行数据降维--通过最大最小距离</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><meta name="referrer" content="no-referrer"><br>( 论文导读：使用半定规划的方法进行数据降维—通过最大最小距离[Max-min distance analysis by using sequential SDP relaxation for dimension reduction])<br><em>可能是全网第一篇讲解此篇论文的博客</em></p>
<p>本文旨在记录阅读文献时的想法，并不适合小白，有一定数据降维经验的小伙伴会更快上手。<br>原文地址：<a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/5611542">Max-min distance analysis by using sequential SDP relaxation for dimension reduction</a><br>本文的目的是实现数据降维，需要首先了解普通的PCA和LDA[Linear discriminate analysis]的算法。<br>LDA的算法是通过最大化类与类之间的距离和最小化同类之间的方差为目标的算法。目标函数设定为<script type="math/tex">\text{objective} : min  \frac{W^TS_{b}W}{W^TS_{w}W}</script><br>具体的请移步：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16137569/article/details/82385050?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159842013019724843303257%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=159842013019724843303257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-82385050.pc_ecpm_v3_pc_rank_v3&amp;utm_term=LDA&amp;spm=1018.2118.3001.4187">LDA</a></p>
<h1 id="1-系统模型"><a href="#1-系统模型" class="headerlink" title="1. 系统模型"></a>1. 系统模型</h1><p>&emsp; 本文的方法提出一个新的优化目标：最大化类别间的最小距离。根据木桶原理，分类的性能瓶颈肯定受限于最小的距离的两个类别。最小的距离被优化了，那么整体的性能肯定会得到优化。<br>&emsp; 设定好了目标函数以后我们可以显式的把优化问题表达出来：<br>&emsp; 考虑一个$C$种类别的分类问题，假设每一个类别之内的数据点的分布都是同样方差(==不同也没有关系==)的高斯分布。大概如下如图所示：<br><img src="https://img-blog.csdnimg.cn/20200826192530326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYXJlNzI3MTg2NjMw,size_16,color_FFFFFF,t_70#pic_center" alt="同方差的3类分布"><br>对于每一个$\omega_i$类别都有条件分布$p(\boldsymbol{x}|\omega_i)=\mathcal N(\mathbf{\mu_i,\Sigma|\omega_i})$,其中$\boldsymbol{x}\in\mathbb{R}^m$,$\mathbf{y}=\boldsymbol{W}^T\boldsymbol{x}\in\mathbb{R}^{ {d} }$,其中$\boldsymbol{W}\in\mathbb{R}^{m\times{d} }$，$\boldsymbol{x}$是原数据向量，$\boldsymbol{y}$是降维后的数据向量，$\boldsymbol{W}$是降维矩阵。==<em>此处原文章出错</em>==<br><img src="https://img-blog.csdnimg.cn/20200828095447987.png#pic_center" alt="原文"></p>
<h2 id="1-1数学表示"><a href="#1-1数学表示" class="headerlink" title="1.1数学表示"></a>1.1数学表示</h2><p>&emsp;每个类别间的数据的方差可以随意假设，文章中假设$\boldsymbol{\Sigma}=\boldsymbol{I}$,现在$\omega_i$和$\omega_j$两个类别的中心距离变成了</p>
<script type="math/tex; mode=display">\begin{aligned}
\Delta(\omega_i,\omega_j|\boldsymbol{W})&=tr(\boldsymbol{W}^T\boldsymbol{D}_{ij}\boldsymbol{W})\\subject\;{to}\boldsymbol{W}^T\boldsymbol{W}&=\boldsymbol{I}_d
\end{aligned}</script><p>$\boldsymbol{W}^T\boldsymbol{W}=\boldsymbol{I}_d$是为了让$\mathbf{W}$单位化，其中$\boldsymbol{D}_{ij}$是矩阵:<script type="math/tex">\boldsymbol{D}_{ij}=(\mu_i-\mu_j)(\mu_i-\mu_j)^T,</script><br>这个矩阵被称为类别$\omega_i$和$\omega_j$的距离矩阵，这个矩阵的迹就是未变换前的两个类别中心的距离了。变换后的迹既是:<script type="math/tex">tr(\boldsymbol{W}^T\boldsymbol{D}_{ij}\boldsymbol{W})=\|\boldsymbol{W^T(\mu_i-\mu_j)}\|^2.</script><br>&emsp;我们的优化目标便是这个了，找到所有类别中心距离最短的距离MMDA(Max-min distance analysis):<script type="math/tex">\underset{\boldsymbol{W}^T\boldsymbol{W}=\boldsymbol{I}_d}{\text{max}} \quad \underset{1\leq{i}\leq{j}\leq{C}}{\text{min}}\quad\Delta(\omega_i,\omega_j|\boldsymbol{W})。</script><br>这乍一看，这个优化问题咋做啊，无从下手啊，每次都遍历一边吗，怎么求导啊？别着急，聪明的作者做了一个变形。</p>
<hr>
<h2 id="1-2优化模型"><a href="#1-2优化模型" class="headerlink" title="1.2优化模型"></a>1.2优化模型</h2><p>&emsp;引入一个辅助变量$t$，令$t={\text{min}\quad\underset{1 \leq {i}  &lt;  j  \leq  {c}}\Delta(\omega_i,\omega_j|\boldsymbol{W})}，$这样模型就变成了</p>
<script type="math/tex; mode=display">\begin{aligned}
\text{max}\quad& t\\
\text{s.t.}\quad&Tr(\boldsymbol{D}_{ij}\mathbf{X})\geq{t},1\leq{i}<j\leq{C}.
\end{aligned}</script><p>诶，这样一看是不是问题有点头绪了，学习过凸优化的同学应该能看出来这好像是半定规划的问题。但是半定规划有一个$\boldsymbol{X}\succeq\mathbf{0}$啊。这里需要嘛？而且这里好像对$\boldsymbol{X}$的限制没有体现出$\boldsymbol{W}^T\boldsymbol{W}=\boldsymbol{I}_d$。<br>&emsp;你想得没错，这里需要插入一条引理</p>
<ol>
<li><blockquote>
<p>如果$\Omega_1是这样的 集合：\Omega_1=\{\mathbf{X}|\mathbf{X}=\mathbf{W}\mathbf{W^T},\mathbf{W^T}\mathbf{W}=\boldsymbol{I}_d\}，而\Omega_2=\{\mathbf{X}|Tr(\mathbf{X})=d,\mathbf{0}\preceq\mathbf{X}\preceq{\mathbf{I}}\}$。那么$\Omega_2$是$\Omega_1$的最小凸包，$\Omega_1$是$\Omega_2$的极点</p>
</blockquote>
</li>
</ol>
<p>什么？你不知道什么是极点，什么是凸包？自己百度去。好吧，集合的==极点==就是==不能集合中其他的点线性表示出来的点==，==凸包==就是包含此集合的最小凸集。所以引理1的证明非常直观，直接用定义即可。$\Omega_1$和$\Omega_2$的本质差在哪？<br>$\Omega_1$规定了$rank(\boldsymbol{X})=d$,而$\Omega_2$没有做此规定，所以$\Omega_2$中的$X$的rank可以是$1\leq rank(\boldsymbol{X})\leq{m}$。<br>&emsp;怎么证明引理1呢？我给出一个不严谨的证明</p>
<blockquote>
<p>$\Omega_1\subseteq\Omega_2$很明显，并且很明显$rank(\boldsymbol{X})\not =d$的$X_1$,$X_2\in\Omega_2$的线性组合不可能表示成$rank(\boldsymbol{X}) =d$且$Tr(\boldsymbol{X})=d$<br><em>还是给出一个</em>证明吧，写这玩意太费时了<img src="https://img-blog.csdnimg.cn/20200922152310626.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYXJlNzI3MTg2NjMw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</blockquote>
<p>好了，此时的可行域变大了，可行域从极点变成了凸包，这就是我们文章中松弛所在的地方。这时松弛的优化问题变成了</p>
<script type="math/tex; mode=display">\begin{aligned}
\text{min}\quad&-t\\
s.t\quad&tr(\boldsymbol{A}_{ij}\boldsymbol{X})\geq    t\quad1\leq{i}<j\leq{C}\\
&tr{(\boldsymbol{X})}=d\\
&0\preceq\boldsymbol{X}\preceq\boldsymbol{I}
\end{aligned}</script><p>这是不是一个标准的SDP(semidefinte programming)问题?<br>啥？你不知道啥是SDP？这里简单的说一下SDP的标准形式吧</p>
<blockquote>
<script type="math/tex; mode=display">\begin{aligned}
{minimize} \quad& \mathbf {tr}(CX) \\
{subject\quad to}\quad& \mathbf{tr}(A_iX) = b_i, \quad i=1,\ldots,p \\
                  & X \succeq 0,
\end{aligned}</script></blockquote>
<p>不会吧不会吧，不会到了这一步还有人不知道怎么把问题变成标准的SDP形式吧。没办法了，我只好写得详细一些</p>
<script type="math/tex; mode=display">
\begin{aligned}
111
\end{aligned}</script>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/01/%E8%AE%BA%E6%96%87%E5%AF%BC%E8%AF%BB%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9D%BE%E5%BC%9B%E5%8D%8A%E5%AE%9A%E8%A7%84%E5%88%92%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4--%E9%80%9A%E8%BF%87%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/" data-id="clr7f8dt1000gnkvt44wldscz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="categories/%E4%BF%A1%E5%8F%B7/">信号</a></li><li class="category-list-item"><a class="category-list-link" href="categories/%E7%BC%96%E7%A8%8B/">编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="tags/Pytorch/" rel="tag">Pytorch</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/tensorflow/" rel="tag">tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" rel="tag">统计学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="tags/Pytorch/" style="font-size: 10px;">Pytorch</a> <a href="tags/tensorflow/" style="font-size: 10px;">tensorflow</a> <a href="tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" style="font-size: 20px;">统计学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="archives/2022/06/">June 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="2022/06/06/%E5%B0%8F%E7%99%BD%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%8D%B7%E7%A7%AF/">小白也能看懂的卷积！</a>
          </li>
        
          <li>
            <a href="2022/06/02/MCMC%E7%B3%BB%E5%88%97%EF%BC%9AMetropololis-Hasting%E9%87%87%E6%A0%B7%E7%AE%97%E6%B3%95%EF%BC%8C10%E5%88%86%E9%92%9F%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%A4%A7%E7%A5%9E/">MCMC系列：Metropololis-Hasting采样算法，10分钟从零到大神</a>
          </li>
        
          <li>
            <a href="2022/06/02/Tensor%20%E5%82%A8%E5%AD%98%E5%AD%97%E5%85%B8%E7%9A%84key%EF%BC%8C%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E5%85%B8%E7%9A%84value%E5%A1%AB%E5%85%A5Tensor/">Tensor 储存字典的key，如何将字典的value填入Tensor</a>
          </li>
        
          <li>
            <a href="2022/06/02/%E5%A4%8D%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/">复随机变量</a>
          </li>
        
          <li>
            <a href="2022/06/02/Trace%E2%80%94%CF%83%E4%BB%A3%E6%95%B0%E7%9A%84%E8%AF%81%E6%98%8E/">Trace—σ代数的证明</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="index.html" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="fancybox/jquery.fancybox.css">

  
<script src="fancybox/jquery.fancybox.pack.js"></script>




<script src="js/script.js"></script>




  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>